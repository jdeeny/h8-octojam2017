###############################
##                           ##
##   BERGSTEIGERSIMULATOR    ##
##                           ##
##   d8b    d8b  88    88    ##
##   888    888  .d8888b.    ##
##   888    888 d88P  Y88b   ##
##   8888888888 Y88b. d88P   ##
##   8888888888  "Y88888"    ##
##   888    888 .d8P""Y8b.   ##
##   888    888 888    888   ##
##   888    888 Y88b  d88P   ##
##   Y8P    Y8P  "Y8888P"    ##
##                           ##
###############################

# A mountaineering simulator and entry for `Octojam IV`.
#
# This program is designed to target a bug-fixed version of the SuperChip
# emulator `SCHIP` running on an HP48 GX calculator, as well as the Octo
# emulator. It has not been tested on other platforms.
#
# This program uses instructions from the SuperChip instruction set extension.
# It assumes sprites are clipped to the screen edge, but otherwise assumes the
# emulator does not have the classic SCHIP emulation bugs.
#

:const KB_1 0x1 :const KB_2 0x2 :const KB_3 0x3 :const KB_4 0xC
:const KB_Q 0x4 :const KB_W 0x5 :const KB_E 0x6 :const KB_R 0xD
:const KB_A 0x7 :const KB_S 0x8 :const KB_D 0x9 :const KB_F 0xE
:const KB_Z 0xA :const KB_X 0x0 :const KB_C 0xB :const KB_V 0xF

:calc KEY_LEFT { KB_A }
:calc KEY_RIGHT { KB_D }
:calc KEY_UP { KB_W }
:calc KEY_DOWN { KB_S }

# This could be switch instead of a dedicated key for each
:calc KEY_LH { KB_Q }
:calc KEY_RH { KB_E }
:calc KEY_LF { KB_Z }
:calc KEY_RF { KB_C }

:macro draw label x y h { i := label sprite x y h }
:macro ifkey keynum { vF := keynum if vF key then }

: main
	hires
	title_draw
	vF := key
	clear

	climbing_init
	climbing_run

	: main_loop
	loop
	again

#########################
### Code Modification ###
#########################
:macro hilo value { :calc hi { value >> 8 } :calc lo { value & 0xFF } }

# Allocates space for a trampoline
:macro Trampoline: label {
  : label jump label
}

:macro Trampoline-Set-I-Const label target {
  hilo target
  :calc hi { 0xA0 | hi }
  v0 := hi
  v1 := lo
  i := label
  save v1
}

### End Code Modification

################
### Climbing ###
################
:calc CLIMBING_SPEED { 2 }
:calc CLIMBING_SPEED_REVERSE { 0 - CLIMBING_SPEED }
:const CLIMBING_FRAME_DELAY 2

:alias Climbing_View v6
:alias Climbing_Moving v7
:alias Climbing_Debounce v8
:alias Climbing_X v9
:alias Climbing_Y vA
:alias Climbing_DeltaX vB
:alias Climbing_DeltaY vC
:alias Climbing_Limb vD

# Store the limb as the keycode so we can scan that key quickly
:calc LIMB_NONE { 0xFF }
:calc LIMB_LEFTHAND { KEY_LH }
:calc LIMB_RIGHTHAND { KEY_RH }
:calc LIMB_LEFTFOOT { KEY_LF }
:calc LIMB_RIGHTFOOT { KEY_RF }

:const LEFT_HAND_LIMIT 16
:const RIGHT_HAND_LIMIT 96
:const TOP_HAND_LIMIT 0
:const BOT_HAND_LIMIT 48

:const CLIMBING_VIEW_HANDS 0
:const CLIMBING_VIEW_FEET 1

# Storage of limb coordinates, LH XY, RH XY, LF XY, RF XY
:const CLIMBING_DATA_BYTES 2
: climbing_data
: climbing_data_lefthand 		0 0
: climbing_data_righthand		0 0
: climbing_data_leftfoot 		0 0
: climbing_data_rightfoot		0 0

# This sets up the beginning of a climbing session
#  - loads level data, sets limb locations etc
: climbing_init
	# Setup some initial XY coords for the limbs
	i := climbing_data
	v0 := 40
	v1 := 30
	save v1
	v0 := 80
	save v1
	v0 := 40
	save v1
	v0 := 80
	save v1
	;

# This loops around idling, waiting for limb select and moving a limb onto a hold
: climbing_run
	# Setup
	Climbing_Limb := LIMB_NONE
	Climbing_Moving := 0
	Climbing_View := CLIMBING_VIEW_HANDS

	# Draw the initial limbs
	climbing_draw_lefthand
	climbing_draw_righthand

	: climbing_main_loop
	loop
		# Don't select a limb if we are moving already
		if Climbing_Moving != 0 then jump climbing_moving_limb

		# Scan limb selection keys
		ifkey KEY_LH Climbing_Limb := LIMB_LEFTHAND
		ifkey KEY_RH Climbing_Limb := LIMB_RIGHTHAND
		ifkey KEY_LF Climbing_Limb := LIMB_LEFTFOOT
		ifkey KEY_RF Climbing_Limb := LIMB_RIGHTFOOT

		# Don't do anything if no limb was selected
		if Climbing_Limb == LIMB_NONE then jump climbing_delay_loop

		# Select a new limb and start moving it
		: climbing_begin_move
		# At this point, a limb is selected (Climbing_Limb := LIMB_XXX)

		# If the selection switchs between hand/foot, update screen appropriately

		# Setup the limb drawing function to do the right thing and load Climbing X/Y
		if Climbing_Limb == LIMB_LEFTHAND then climbing_setup_drawlimb_lefthand
		if Climbing_Limb == LIMB_RIGHTHAND then climbing_setup_drawlimb_righthand

		# i is set equal to the correct data area by the above setup functions
		load v1
		Climbing_X := v0
		Climbing_Y := v1

		# Initialize before move loop
		Climbing_Debounce := 0	# Clear debounce flag
		Climbing_Moving := 1		# Moving = True
		Climbing_DeltaX := 0
		Climbing_DeltaY := 0

		# Move a limb
		: climbing_moving_limb

			# Erase, update XY, and redraw the limb
				: climbing_redraw_limb
				# Erase limb
					climbing_drawlimb
				# Adjust x/y
					Climbing_X += Climbing_DeltaX
					Climbing_Y += Climbing_DeltaY
				# Observe some limits to movement

				# Draw limb
					climbing_drawlimb

			# Scan movement keys and adjust delta x/y
				: climbing_scan_movement_keys
				Climbing_DeltaX := 0
				Climbing_DeltaY := 0
				ifkey KEY_LEFT Climbing_DeltaX += CLIMBING_SPEED_REVERSE
				ifkey KEY_RIGHT Climbing_DeltaX += CLIMBING_SPEED
				ifkey KEY_UP Climbing_DeltaY += CLIMBING_SPEED_REVERSE
				ifkey KEY_DOWN Climbing_DeltaY += CLIMBING_SPEED

			# Add random jitter to the delta x/y
				v0 := random 0b00001100
				vF := random 0b00000001
				jump0 climbing_randtable
				: climbing_randtable
				Climbing_DeltaX += vF
				jump climbing_endrand
				Climbing_DeltaX -= vF
				jump climbing_endrand
				Climbing_DeltaY += vF
				jump climbing_endrand
				Climbing_DeltaY -= vF
				: climbing_endrand


			# Check keys to see if we are finished moving
				: climbing_scan_moveend_keys
				# If we are not debounced, don't allow switch
				if Climbing_Debounce == 0 then jump climbing_check_debounce
				if Climbing_Limb key then jump climbing_exit_movement	# Exit if they press the same limb key again
				jump climbing_delay_loop

				: climbing_check_debounce
				if Climbing_Limb -key then Climbing_Debounce := 1		# Set debounced flag if the key was released
				jump climbing_delay_loop

		# Limb movement is over, determine if the move landed on a hold
		: climbing_exit_movement
		# Cheap debounce
		loop while Climbing_Limb key again

		# Save limb data to ram
		if Climbing_Limb == LIMB_LEFTHAND then i := climbing_data_lefthand
		if Climbing_Limb == LIMB_RIGHTHAND then i := climbing_data_righthand
		if Climbing_Limb == LIMB_LEFTFOOT then i := climbing_data_leftfoot
		if Climbing_Limb == LIMB_RIGHTFOOT then i := climbing_data_rightfoot
		v0 := Climbing_X
		v1 := Climbing_Y
		save v1

		# Clear limb
		Climbing_Moving := 0
		Climbing_Limb := LIMB_NONE

		# Delay and Continue with idle
		: climbing_delay_loop
		loop
			vF := delay
			while vF != 0
		again
		vF := CLIMBING_FRAME_DELAY
		delay := vF
	again
	;


# Does everything needed to draw the left hand/arm cold (ie not in the climbing move loop)
# TODO: Could surely be made more compact
: climbing_draw_lefthand
	i := climbing_data_lefthand
	load v1
	Climbing_X := v0
	Climbing_Y := v1
	climbing_setup_drawlimb_lefthand
	climbing_drawlimb
	;

: climbing_draw_righthand
	i := climbing_data_righthand
	load v1
	Climbing_X := v0
	Climbing_Y := v1
	climbing_setup_drawlimb_righthand
	climbing_drawlimb
	;


: climbing_drawlimb
	Trampoline: climbing_tramp_i:=handsprite
	sprite Climbing_X Climbing_Y 0
	i := spr_arm
	v0 := Climbing_Y
	vF := 0b01110000
	vF &= Climbing_Y
	if vF == 0 then jump climbing_erase_3
	if vF == 16 then jump climbing_erase_2
	if vF == 32 then jump climbing_erase_1
	return
	: climbing_erase_3
	v0 += 16
	sprite Climbing_X v0 0
	: climbing_erase_2
	v0 += 16
	sprite Climbing_X v0 0
	: climbing_erase_1
	v0 += 16
	sprite Climbing_X v0 0
	;


### End Climbing

####################
### Title Screen ###
####################
:const TITLE_CHAR_WIDTH 16

:const TITLE_H8_YOFFSET 17
:const TITLE_H8_SPACING 6
:calc TITLE_H8_XSKIP { TITLE_H8_SPACING + 16 }
:calc TITLE_H8_XOFFSET { 64 - ( ( TITLE_CHAR_WIDTH + TITLE_H8_XSKIP ) / 2 ) }

:calc TITLE_LH_XOFFSET { TITLE_H8_XOFFSET / 3 }
:calc TITLE_LH_YOFFSET { 64 - 6 }
:calc TITLE_RH_XOFFSET { TITLE_H8_XOFFSET + 19 }
:calc TITLE_RH_YOFFSET { TITLE_H8_YOFFSET + 27 }


:const TITLE_SUB_WIDTH 8
:const TITLE_SUB_HEIGHT 5
:const TITLE_SUB_TILES 10
:calc TITLE_SUB_TOTAL_WIDTH { ( TITLE_SUB_WIDTH * TITLE_SUB_TILES ) - 3 } # Subtract for empty cols at end
:calc TITLE_SUB_XOFFSET { 64 - ( TITLE_SUB_TOTAL_WIDTH / 2 ) }
:calc TITLE_SUB_YOFFSET { TITLE_H8_YOFFSET - 10 }
:calc TITLE_SUB_XEND { TITLE_SUB_XOFFSET + ( TITLE_SUB_WIDTH * TITLE_SUB_TILES ) }

: title_draw
	clear
	v0 := TITLE_H8_XOFFSET
	v1 := TITLE_H8_YOFFSET
	draw spr_title_htop v0 v1 0
	v1 += 16
	draw spr_title_hbot v0 v1 0
	v0 += TITLE_H8_XSKIP
	draw spr_title_8bot v0 v1 0
	v1 += -16
	draw spr_title_8top v0 v1 0
	Climbing_X := TITLE_LH_XOFFSET
	Climbing_Y := TITLE_LH_YOFFSET
	climbing_setup_drawlimb_lefthand
	climbing_drawlimb
	Climbing_X := TITLE_RH_XOFFSET
	Climbing_Y := TITLE_RH_YOFFSET
	climbing_setup_drawlimb_righthand
	climbing_drawlimb

	v1 := TITLE_SUB_XOFFSET
	v2 := TITLE_SUB_YOFFSET
	v0 := TITLE_SUB_HEIGHT
	i := spr_title_sub_be
	loop
		sprite v1 v2 TITLE_SUB_HEIGHT
		v1 += TITLE_SUB_WIDTH
		i += v0
		while v1 != TITLE_SUB_XEND
	again
	;
### End Title Screen

###############
### Sprites ###
###############
: spr_righthand
0x01 0x40 0x06 0xA0 0x02 0xA8 0x0A 0xA8
0x0B 0xF8 0x0F 0xF0 0x0F 0xF0 0x07 0xE0
0x03 0xC0 0x03 0xC0 0x03 0xC0 0x03 0xC0
0x03 0xC0 0x03 0xC0 0x03 0xC0 0x03 0xC0

: spr_lefthand
0x02 0x80 0x05 0x60 0x15 0x40 0x15 0x50
0x1F 0xD0 0x0F 0xF0 0x0F 0xF0 0x07 0xE0
0x03 0xC0 0x03 0xC0 0x03 0xC0 0x03 0xC0
0x03 0xC0 0x03 0xC0 0x03 0xC0 0x03 0xC0

: spr_arm
0x03 0xC0 0x03 0xC0 0x03 0xC0 0x03 0xC0
0x03 0xC0 0x03 0xC0 0x03 0xC0 0x03 0xC0
0x03 0xC0 0x03 0xC0 0x03 0xC0 0x03 0xC0
0x03 0xC0 0x03 0xC0 0x03 0xC0 0x03 0xC0

: spr_rightfoot
0x07 0xE0 0x07 0xE0 0x07 0xE0 0x07 0xE0
0x07 0xE0 0x07 0xE0 0x07 0xE0 0x07 0xE0
0x07 0xE0 0x07 0xE0 0x07 0xE0 0x03 0xE0
0x03 0xC0 0x07 0xFC 0x07 0xFE 0x03 0xFE

: spr_leftfoot
0x07 0xE0 0x07 0xE0 0x07 0xE0 0x07 0xE0
0x07 0xE0 0x07 0xE0 0x07 0xE0 0x07 0xE0
0x07 0xE0 0x07 0xE0 0x07 0xE0 0x07 0xC0
0x03 0xC0 0x3F 0xE0 0x7F 0xE0 0x7F 0xC0

: spr_leg
0x07 0xE0 0x07 0xE0 0x07 0xE0 0x07 0xE0
0x07 0xE0 0x07 0xE0 0x07 0xE0 0x07 0xE0
0x07 0xE0 0x07 0xE0 0x07 0xE0 0x07 0xE0
0x07 0xE0 0x07 0xE0 0x07 0xE0 0x07 0xE0

# Some holds, these are 3 tall ellipses
: spr_hold_3x3 0x40 0xA0 0x40
: spr_hold_3x4 0x60 0x90 0x60
: spr_hold_3x5 0x70 0x88 0x70
: spr_hold_3x6 0x78 0x84 0x78
: spr_hold_3x7 0x7C 0x82 0x7C
: spr_hold_3x8 0x7E 0x81 0x7E

: spr_title_htop
0x00 0x00 0x60 0x06 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xFF 0xFF 0xFF 0xFF

: spr_title_hbot
0xFF 0xFF 0xFF 0xFF 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF0 0x0F 0x60 0x06

: spr_title_8top
0x30 0x0C 0x78 0x1E 0x78 0x1E 0x30 0x0C
0x07 0xE0 0x1F 0xF8 0x3F 0xFC 0x7F 0xFE
0x7C 0x3E 0xF8 0x1F 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF8 0x1F 0x7C 0x3E


: spr_title_8bot
0x3F 0xFC 0x1F 0xF8 0x1F 0xF8 0x3F 0xFC
0x7C 0x3E 0xF8 0x1F 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF8 0x1F 0x7C 0x3E
0x7F 0xFE 0x3F 0xFC 0x1F 0xF8 0x07 0xE0


# H8 - Bergsteigersimulator
: spr_title_sub_be	0xCE 0xA8 0xCC 0xA8 0xCE # BE
: spr_title_sub_rg	0xCE 0xA8 0xCA 0xAA 0xAE # RG
: spr_title_sub_st 	0xEE 0x84 0xE4 0x24 0xE4 # ST
: spr_title_sub_ei 	0xEB 0x8A 0xCA 0x8A 0xEB # EI 1/2 G
: spr_title_sub_ge 	0xBB 0x22 0xB3 0xA2 0xBA # GE 2 col R
: spr_title_sub_rsi 0xBA 0xA2 0x3A 0x8A 0xBA # 1 col R,SI
: spr_title_sub_m 	0x8A 0xDA 0xAA 0x8A 0x8B # M 1/2 U
: spr_title_sub_ula 0xA1 0xA2 0xA3 0xA2 0xBA # 1/2 u L 1/2A
: spr_title_sub_TO	0x3B 0x92 0x92 0x92 0x93 # 1/2 A, T, 1/2 O
: spr_title_sub_R 	0xB8 0xA8 0xB0 0xA8 0xA8 # 1/2 O, R


### Stuff that has to come after sprite declarations
: climbing_setup_drawlimb_lefthand
	Trampoline-Set-I-Const climbing_tramp_i:=handsprite spr_lefthand
	i := climbing_data_lefthand
	;

: climbing_setup_drawlimb_righthand
	Trampoline-Set-I-Const climbing_tramp_i:=handsprite spr_righthand
	i := climbing_data_righthand
	;


# :macro update_righthand {
# 	draw_right_handarm
# 	rhx += Climbing_DeltaX
# 	rhy += Climbing_DeltaY
# 	vF := LEFT_HAND_LIMIT
# 	vF -= rhx
# 	if vF != 0 then rhx := LEFT_HAND_LIMIT
# 	vF := RIGHT_HAND_LIMIT
# 	vF -= rhx
# 	if vF == 0 then rhx := RIGHT_HAND_LIMIT
# 	vF := 64
# 	vF -= rhy
# 	if vF == 0 then rhy := TOP_HAND_LIMIT
# 	vF := BOT_HAND_LIMIT
# 	vF -= rhy
# 	if vF == 0 then rhy := BOT_HAND_LIMIT
#
# 	draw_right_handarm
# 	Climbing_DeltaX := 0
# 	Climbing_DeltaY := 0
# }
