                      ###############################
                      ##                           ##
                      ##   BERGSTEIGERSIMULATOR    ##
                      ##                           ##
                      ##   d8b    d8b  88    88    ##
                      ##   888    888  .d8888b.    ##
                      ##   888    888 d88P  Y88b   ##
                      ##   8888888888 Y88b. d88P   ##
                      ##   8888888888  "Y88888"    ##
                      ##   888    888 .d8P""Y8b.   ##
                      ##   888    888 888    888   ##
                      ##   888    888 Y88b  d88P   ##
                      ##   Y8P    Y8P  "Y8888P"    ##
                      ##                           ##
                      ###############################

# A mountaineering simulator and entry for `Octojam IV`.
#
# This program is designed to target a bug-fixed version of the SuperChip
# emulator `SCHIP` running on an HP48 GX calculator, as well as the Octo
# emulator. It has not been tested on other platforms.
#
# This program uses instructions from the SuperChip instruction set extension.
# It assumes sprites are clipped to the screen edge, but otherwise assumes the
# emulator does not have the classic SCHIP emulation bugs.
#

:const KB_1 0x1 :const KB_2 0x2 :const KB_3 0x3 :const KB_4 0xC
:const KB_Q 0x4 :const KB_W 0x5 :const KB_E 0x6 :const KB_R 0xD
:const KB_A 0x7 :const KB_S 0x8 :const KB_D 0x9 :const KB_F 0xE
:const KB_Z 0xA :const KB_X 0x0 :const KB_C 0xB :const KB_V 0xF

:calc KEY_LEFT { KB_A }
:calc KEY_RIGHT { KB_D }
:calc KEY_UP { KB_W }
:calc KEY_DOWN { KB_S }

# This could be switch instead of a dedicated key for each
:calc KEY_LH { KB_Q }
:calc KEY_RH { KB_E }
:calc KEY_LF { KB_Z }
:calc KEY_RF { KB_C }

:macro draw label x y h { i := label sprite x y h }
:macro ifkey keynum { vF := keynum if vF key then }

: main
	hires
	title_draw
	vF := key
	clear

	climbing_init
	climbing_run

	: main_loop
	loop
	again

#########################
### Code Modification ###
#########################
:macro hilo value { :calc hi { value >> 8 } :calc lo { value & 0xFF } }	# Convenience macro, splits a 16-bit const value into 2 8-bit values

# Allocates space for a trampoline
:macro Trampoline: label {
  : label jump label
}

:macro Trampoline-Set-I-Const label target {
  hilo target
  :calc hi { 0xA0 | hi }
  v0 := hi
  v1 := lo
  i := label
  save v1
}

:macro Trampoline-Set-jmp-Const label target {
  hilo target
  :calc hi { 0x10 | hi }
  v0 := hi
  v1 := lo
  i := label
  save v1
}


### End Code Modification

################
### Climbing ###
################
:calc CLIMBING_SPEED { 2 }
:calc CLIMBING_SPEED_REVERSE { 0 - CLIMBING_SPEED }
:const CLIMBING_FRAME_DELAY 2


:alias Climbing_Limit_Left v4
:alias Climbing_Limit_Right v5
:alias Climbing_View v6
:alias Climbing_Moving v7
:alias Climbing_Debounce v8
:alias Climbing_X v9
:alias Climbing_Y vA
:alias Climbing_DeltaX vB
:alias Climbing_DeltaY vC
:alias Climbing_Limb vD

# Store the limb as the keycode so we can scan that key quickly
:calc LIMB_NONE { 0xFF }
:calc LIMB_LEFTHAND { KEY_LH }
:calc LIMB_RIGHTHAND { KEY_RH }
:calc LIMB_LEFTFOOT { KEY_LF }
:calc LIMB_RIGHTFOOT { KEY_RF }

:const LEFT_HAND_LIMIT 16
:const RIGHT_HAND_LIMIT 96
:const TOP_HAND_LIMIT 0
:const BOT_HAND_LIMIT 48

:const CLIMBING_VIEW_HANDS 0
:const CLIMBING_VIEW_FEET 1

# Storage of limb coordinates, LH XY, RH XY, LF XY, RF XY
:const CLIMBING_DATA_BYTES 2
: climbing_data
: climbing_data_lefthand 		0 0
: climbing_data_righthand		0 0
: climbing_data_leftfoot 		0 0
: climbing_data_rightfoot		0 0

# This sets up the beginning of a climbing session
#  - loads level data, sets limb locations etc
: climbing_init
	# Setup some initial XY coords for the limbs
	i := climbing_data
	v0 := 40
	v1 := 30
	save v1
	v0 := 80
	save v1
	v0 := 40
	v1 := 10
	save v1
	v0 := 80
	save v1
	;

# This loops around idling, waiting for limb select and moving a limb onto a hold
: climbing_run
	# Setup
	Climbing_Limb := LIMB_NONE
	Climbing_Moving := 0
	Climbing_View := CLIMBING_VIEW_HANDS

	# Draw holds


	# Draw the initial limbs
	climbing_draw_lefthand
	climbing_draw_righthand

	: climbing_main_loop
	loop
		# Don't select a limb if we are moving already
		if Climbing_Moving != 0 then jump climbing_moving_limb

		# Scan limb selection keys
		ifkey KEY_LH Climbing_Limb := LIMB_LEFTHAND
		ifkey KEY_RH Climbing_Limb := LIMB_RIGHTHAND
		ifkey KEY_LF Climbing_Limb := LIMB_LEFTFOOT
		ifkey KEY_RF Climbing_Limb := LIMB_RIGHTFOOT

		# Don't do anything if no limb was selected
		if Climbing_Limb == LIMB_NONE then jump climbing_delay_loop

		# Select a new limb and start moving it
		: climbing_begin_move
		# At this point, a limb is selected (Climbing_Limb := LIMB_XXX)

		# If the selection switchs between hand/foot, update screen appropriately
			# Erase old limbs
			# Draw new limbs

		# Setup the limb drawing function to do the right thing and load Climbing X/Y
		if Climbing_Limb == LIMB_LEFTHAND then climbing_setup_drawlimb_lefthand
		if Climbing_Limb == LIMB_RIGHTHAND then climbing_setup_drawlimb_righthand
		if Climbing_Limb == LIMB_LEFTFOOT then climbing_setup_drawlimb_leftfoot
		if Climbing_Limb == LIMB_RIGHTFOOT then climbing_setup_drawlimb_rightfoot

		# i is set equal to the correct data area by the above setup functions
		load v1
		Climbing_X := v0
		Climbing_Y := v1

		# Initialize before move loop
		Climbing_Debounce := 0	# Clear debounce flag
		Climbing_Moving := 1		# Moving = True
		Climbing_DeltaX := 0
		Climbing_DeltaY := 0

		# Move a limb
		: climbing_moving_limb

			# Erase, update XY, and redraw the limb
				: climbing_redraw_limb
				# Erase limb
					climbing_drawlimb
				# Adjust x/y
					Climbing_X += Climbing_DeltaX
					Climbing_Y += Climbing_DeltaY
				# Apply limits
					vF := 0x80
					vF &= Climbing_Y
					if vF != 0 then Climbing_Y := 1

					vF := 0x40
					vF &= Climbing_Y
					if vF != 0 then Climbing_Y := 63

					climbing_set_limits

					vF := Climbing_X
					vF -= Climbing_Limit_Left
					if vF == 0 then Climbing_X := Climbing_Limit_Left

					vF := Climbing_Limit_Right
					vF -= Climbing_X
					if vF == 0 then Climbing_X := Climbing_Limit_Right

				# Draw limb
					climbing_drawlimb

			# Scan movement keys and adjust delta x/y
				: climbing_scan_movement_keys
				Climbing_DeltaX := 0
				Climbing_DeltaY := 0
				ifkey KEY_LEFT Climbing_DeltaX += CLIMBING_SPEED_REVERSE
				ifkey KEY_RIGHT Climbing_DeltaX += CLIMBING_SPEED
				ifkey KEY_UP Climbing_DeltaY += CLIMBING_SPEED_REVERSE
				ifkey KEY_DOWN Climbing_DeltaY += CLIMBING_SPEED

			# Add random jitter to the delta x/y
				v0 := random 0b00001100
				vF := random 0b00000001
				jump0 climbing_randtable
				: climbing_randtable
				Climbing_DeltaX += vF
				jump climbing_endrand
				Climbing_DeltaX -= vF
				jump climbing_endrand
				Climbing_DeltaY += vF
				jump climbing_endrand
				Climbing_DeltaY -= vF
				: climbing_endrand


			# Check keys to see if we are finished moving
				: climbing_scan_moveend_keys
				# If we are not debounced, don't allow switch
				if Climbing_Debounce == 0 then jump climbing_check_debounce
				if Climbing_Limb key then jump climbing_exit_movement	# Exit if they press the same limb key again
				jump climbing_delay_loop

				: climbing_check_debounce
				if Climbing_Limb -key then Climbing_Debounce := 1		# Set debounced flag if the key was released
				jump climbing_delay_loop

		# Limb movement is over, determine if the move landed on a hold
		: climbing_exit_movement
		# Cheap debounce
		loop while Climbing_Limb key again

		# Save limb data to ram
		if Climbing_Limb == LIMB_LEFTHAND then i := climbing_data_lefthand
		if Climbing_Limb == LIMB_RIGHTHAND then i := climbing_data_righthand
		if Climbing_Limb == LIMB_LEFTFOOT then i := climbing_data_leftfoot
		if Climbing_Limb == LIMB_RIGHTFOOT then i := climbing_data_rightfoot
		v0 := Climbing_X
		v1 := Climbing_Y
		save v1

		# Clear limb
		Climbing_Moving := 0
		Climbing_Limb := LIMB_NONE

		# Delay and Continue with idle
		: climbing_delay_loop
		loop
			vF := delay
			while vF != 0
		again
		vF := CLIMBING_FRAME_DELAY
		delay := vF
	again
	;


# Does everything needed to draw the left hand/arm cold (ie not in the climbing move loop)
# TODO: Could surely be made more compact
: climbing_draw_lefthand
	i := climbing_data_lefthand
	load v1
	Climbing_X := v0
	Climbing_Y := v1
	climbing_setup_drawlimb_lefthand
	climbing_drawlimb
	;

: climbing_draw_righthand
	i := climbing_data_righthand
	load v1
	Climbing_X := v0
	Climbing_Y := v1
	climbing_setup_drawlimb_righthand
	climbing_drawlimb
	;


: climbing_drawlimb
	Trampoline: climbing_tramp_i:=handsprite					# To be replaced with `i := <sprite addr>`
	sprite Climbing_X Climbing_Y 8
	i := spr_armleg
	Trampoline: climbing_tramp_jump_drawlimb_armleg		# To be replaced with `jump := climbing_drawlimb_[arm, leg]`
	;

: climbing_drawlimb_arm
	v0 := Climbing_Y
	loop
		v0 += 8
		vF := 63
		vF &= v0
		while vF == v0
		sprite Climbing_X v0 8
	again
	;

: climbing_drawlimb_leg
	v0 := Climbing_Y
	loop
		vF := 8
		vF -= v0
		while vF == 0
		v0 += -8
		sprite Climbing_X v0 8
	again
	v0 <<= v0
	v0 <<= v0
	vF := 0
	jump0 climbing_drawlimb_leg_remainder
	: climbing_drawlimb_leg_remainder
		return return
		sprite Climbing_X vF 1 return
		sprite Climbing_X vF 2 return
		sprite Climbing_X vF 3 return
		sprite Climbing_X vF 4 return
		sprite Climbing_X vF 5 return
		sprite Climbing_X vF 6 return
		sprite Climbing_X vF 7 return


# Sets the movement limits based on the current limb selection
:	climbing_set_limits
	# TODO: Expand to add left-right limits
	if Climbing_Limb == LIMB_LEFTHAND then jump climbing_set_limits_lefthand				# These return to caller
	if Climbing_Limb == LIMB_RIGHTHAND then jump climbing_set_limits_righthand
	if Climbing_Limb == LIMB_LEFTFOOT then jump climbing_set_limits_leftfoot
	if Climbing_Limb == LIMB_RIGHTFOOT then jump climbing_set_limits_rightfoot
	:breakpoint Climbing_Limb_Unknown!
	;


### End Climbing

####################
### Title Screen ###
####################
:const TITLE_CHAR_WIDTH 16

:const TITLE_H8_YOFFSET 17
:const TITLE_H8_SPACING 6
:calc TITLE_H8_XSKIP { TITLE_H8_SPACING + 16 }
:calc TITLE_H8_XOFFSET { 64 - ( ( TITLE_CHAR_WIDTH + TITLE_H8_XSKIP ) / 2 ) }

:calc TITLE_LH_XOFFSET { TITLE_H8_XOFFSET / 3 }
:calc TITLE_LH_YOFFSET { 64 - 6 }
:calc TITLE_RH_XOFFSET { TITLE_H8_XOFFSET + 19 }
:calc TITLE_RH_YOFFSET { TITLE_H8_YOFFSET + 27 }


:const TITLE_SUB_WIDTH 8
:const TITLE_SUB_HEIGHT 5
:const TITLE_SUB_TILES 10
:calc TITLE_SUB_TOTAL_WIDTH { ( TITLE_SUB_WIDTH * TITLE_SUB_TILES ) - 3 } # Subtract for empty cols at end
:calc TITLE_SUB_XOFFSET { 64 - ( TITLE_SUB_TOTAL_WIDTH / 2 ) }
:calc TITLE_SUB_YOFFSET { TITLE_H8_YOFFSET - 10 }
:calc TITLE_SUB_XEND { TITLE_SUB_XOFFSET + ( TITLE_SUB_WIDTH * TITLE_SUB_TILES ) }

: title_draw
	clear
	v0 := TITLE_H8_XOFFSET
	v1 := TITLE_H8_YOFFSET
	draw spr_title_htop v0 v1 0
	v1 += 16
	draw spr_title_hbot v0 v1 0
	v0 += TITLE_H8_XSKIP
	draw spr_title_8bot v0 v1 0
	v1 += -16
	draw spr_title_8top v0 v1 0
	Climbing_X := TITLE_LH_XOFFSET
	Climbing_Y := TITLE_LH_YOFFSET
	climbing_setup_drawlimb_lefthand
	climbing_drawlimb
	Climbing_X := TITLE_RH_XOFFSET
	Climbing_Y := TITLE_RH_YOFFSET
	climbing_setup_drawlimb_righthand
	climbing_drawlimb

	v1 := TITLE_SUB_XOFFSET
	v2 := TITLE_SUB_YOFFSET
	v0 := TITLE_SUB_HEIGHT
	i := spr_title_sub_be
	loop
		sprite v1 v2 TITLE_SUB_HEIGHT
		v1 += TITLE_SUB_WIDTH
		i += v0
		while v1 != TITLE_SUB_XEND
	again
	;
### End Title Screen

###############
### Sprites ###
###############
: spr_righthand			# 8x8 px version
0x14 0x6A 0x2B 0xAB 0xBF 0xFF 0xFF 0x7E

: spr_lefthand
0x28 0x56 0xD4 0xD5 0xFD 0xFF 0xFF 0x7E

: spr_armleg
0x3C 0x3C 0x3C 0x3C 0x3C 0x3C 0x3C 0x3C

: spr_rightfoot
0x7E 0x7F 0x00 0x00 0x00 0x00 0x00 0x00

: spr_leftfoot
0x7E 0xFE 0x00 0x00 0x00 0x00 0x00 0x00


# Some holds, these are 3 tall ellipses
:const Hold_Height 3

:calc hold_acc { 0 }
:macro define_hold id {
	:calc id { hold_acc }
	:calc hold_acc { hold_acc + Hold_Height }
}
: spr_holds
define_hold HOLD_3X3 : spr_hold_3x3 0x40 0xA0 0x40
define_hold HOLD_3X4 : spr_hold_3x4 0x60 0x90 0x60
define_hold HOLD_3X5 : spr_hold_3x5 0x70 0x88 0x70
define_hold HOLD_3X6 : spr_hold_3x6 0x78 0x84 0x78
define_hold HOLD_3X7 : spr_hold_3x7 0x7C 0x82 0x7C
define_hold HOLD_3X8 : spr_hold_3x8 0x7E 0x81 0x7E
:const HOLD_END 0xFF

: spr_title_htop
0x00 0x00 0x60 0x06 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xFF 0xFF 0xFF 0xFF

: spr_title_hbot
0xFF 0xFF 0xFF 0xFF 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF0 0x0F 0x60 0x06

: spr_title_8top
0x30 0x0C 0x78 0x1E 0x78 0x1E 0x30 0x0C
0x07 0xE0 0x1F 0xF8 0x3F 0xFC 0x7F 0xFE
0x7C 0x3E 0xF8 0x1F 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF8 0x1F 0x7C 0x3E


: spr_title_8bot
0x3F 0xFC 0x1F 0xF8 0x1F 0xF8 0x3F 0xFC
0x7C 0x3E 0xF8 0x1F 0xF0 0x0F 0xF0 0x0F
0xF0 0x0F 0xF0 0x0F 0xF8 0x1F 0x7C 0x3E
0x7F 0xFE 0x3F 0xFC 0x1F 0xF8 0x07 0xE0


# H8 - Bergsteigersimulator
: spr_title_sub_be	0xCE 0xA8 0xCC 0xA8 0xCE # BE
: spr_title_sub_rg	0xCE 0xA8 0xCA 0xAA 0xAE # RG
: spr_title_sub_st 	0xEE 0x84 0xE4 0x24 0xE4 # ST
: spr_title_sub_ei 	0xEB 0x8A 0xCA 0x8A 0xEB # EI 1/2 G
: spr_title_sub_ge 	0xBB 0x22 0xB3 0xA2 0xBA # GE 2 col R
: spr_title_sub_rsi 0xBA 0xA2 0x3A 0x8A 0xBA # 1 col R,SI
: spr_title_sub_m 	0x8A 0xDA 0xAA 0x8A 0x8B # M 1/2 U
: spr_title_sub_ula 0xA1 0xA2 0xA3 0xA2 0xBA # 1/2 u L 1/2A
: spr_title_sub_TO	0x3B 0x92 0x92 0x92 0x93 # 1/2 A, T, 1/2 O
: spr_title_sub_R 	0xB8 0xA8 0xB0 0xA8 0xA8 # 1/2 O, R


### Climbing legal moves table
# This is entirely from the perspective of the left arm
:const climbing_leftright_offset 8				# Distance from limb 'root' to centroid
:const climbing_limb_length 32						# Length of a limb
:const climbing_hand_width 8
:calc climbing_width { ( climbing_leftright_offset * 2 ) + ( climbing_limb_length * 2 ) }			# The full width of the visible play area
:calc climbing_center { 64 }
:calc climbing_left { climbing_center - ( climbing_width / 2 ) }
:calc climbing_right { climbing_center + ( climbing_width / 2 ) }

# Creates 1 line of the table, limits are adjusted by left-cut right-cut (not absolute)
:macro climbing_table_entry left-cut right-cut {
	:calc left-lim { climbing_left + left-cut }			# Calc limits
	:calc right-lim { ( ( climbing_right - right-cut ) - ( climbing_leftright_offset * 3 ) ) - climbing_hand_width }
	:byte left-lim :byte right-lim												# Output bytes
}

# In: v0 = y-coordinate
# Out: v0 = left-limit, v1 = right limit
:macro climbing_limit_lookup {
	v0 <<= v0
	i := climbing_limit_table
	i += v0
	load v1
}

: climbing_set_limits_lefthand
	v0 := Climbing_Y
	climbing_limit_lookup
	Climbing_Limit_Left := v0
	Climbing_Limit_Right := v1
	;

: climbing_set_limits_righthand
	v0 := Climbing_Y
	climbing_limit_lookup
	:calc lim { 127 - ( climbing_hand_width * 2 ) }
	Climbing_Limit_Left := lim
	Climbing_Limit_Left -= v1
	Climbing_Limit_Right := lim
	Climbing_Limit_Right -= v0
	;

: climbing_set_limits_leftfoot
	v0 := 63
	v0 -= Climbing_Y
	climbing_limit_lookup
	Climbing_Limit_Left := v0
	Climbing_Limit_Right := v1
	;

: climbing_set_limits_rightfoot
	v0 := 63
	v0 -= Climbing_Y
	climbing_limit_lookup
	Climbing_Limit_Left := 127
	Climbing_Limit_Left -= v1
	Climbing_Limit_Right := 127
	Climbing_Limit_Right -= v0
	;


: climbing_limit_table
# Given a Y coordinate, return the X limits. Numbers given are the pixels 'cut out'
# from the edge, but the table is actually filled with raw screen x coordinates
	climbing_table_entry 17 17		#  0
	climbing_table_entry 14 14		#  1
	climbing_table_entry 12 12		#  2
	climbing_table_entry 10 10		#  3
	climbing_table_entry  9  9		#  4
	climbing_table_entry  8  8		#  5
	climbing_table_entry  7  7		#  6
	climbing_table_entry  6  6		#  7
	climbing_table_entry  5  5		#  8
	climbing_table_entry  4  4		#  9
	climbing_table_entry  4  4		# 10
	climbing_table_entry  3  3		# 11
	climbing_table_entry  3  3		# 12
	climbing_table_entry  2  2		# 13
	climbing_table_entry  2  2		# 14
	climbing_table_entry  2  2		# 15
	climbing_table_entry  1  1		# 16
	climbing_table_entry  1  1		# 17
	climbing_table_entry  1  1		# 18
	climbing_table_entry  1  1		# 19
	climbing_table_entry  0  0		# 20
	climbing_table_entry  0  0		# 21
	climbing_table_entry  0  0		# 22
	climbing_table_entry  0  0		# 23
	climbing_table_entry  0  0		# 24
	climbing_table_entry  0  0		# 25
	climbing_table_entry  0  0		# 26
	climbing_table_entry  0  0		# 27
	climbing_table_entry  0  0		# 28
	climbing_table_entry  0  0		# 29
	climbing_table_entry  0  0		# 30
	climbing_table_entry  0  0		# 31
	climbing_table_entry  0  0		# 32
	climbing_table_entry  0  0		# 33
	climbing_table_entry  0  0		# 34
	climbing_table_entry  0  0		# 35
	climbing_table_entry  0  0		# 36
	climbing_table_entry  0  0		# 37
	climbing_table_entry  0  0		# 38
	climbing_table_entry  0  0		# 39
	climbing_table_entry  0  0		# 40
	climbing_table_entry  0  0		# 41
	climbing_table_entry  0  0		# 42
	climbing_table_entry  0  0		# 43
	climbing_table_entry  0  0		# 44
	climbing_table_entry  0  0		# 45
	climbing_table_entry  0  0		# 46
	climbing_table_entry  0  0		# 47
	climbing_table_entry  0  0		# 48
	climbing_table_entry  0  0		# 49
	climbing_table_entry  0  0		# 50
	climbing_table_entry  0  0		# 51
	climbing_table_entry  0  0		# 52
	climbing_table_entry  0  0		# 53
	climbing_table_entry  0  0		# 54
	climbing_table_entry  1  1		# 55
	climbing_table_entry  1  1		# 56
	climbing_table_entry  1  1		# 57
	climbing_table_entry  2  2		# 58
	climbing_table_entry  2  2		# 59
	climbing_table_entry  3  3		# 60
	climbing_table_entry  4  4		# 61
	climbing_table_entry  6  6		# 62
	climbing_table_entry  9  9		# 63


### Level Map

:alias Climbing_TempX v1
:alias Climbing_TempY v2

:macro maptile-reset {
	Climbing_TempX := 0
	Climbing_TempX -= Climbing_X
	Climbing_TempY := 0
	Climbing_TempY -= Climbing_Y
	:calc maptile-lastx { 0 }
	:calc maptile-lasty { 0 }
}

:macro maptile-entry x y sprite-addr {
	i := sprite-addr
	:calc maptile-deltax { x - maptile-lastx }
	:calc maptile-lastx { x }
	:calc maptile-deltay { y - maptile-lasty }
	:calc maptile-lasty { y }

	Climbing_TempX += maptile-deltax
	Climbing_TempY += maptile-deltay

	climbing_map_check_limits_and_sprite
}

: climbing_map_check_limits_and_sprite
	v0 := 0
	# Check Y limit
	vF := 0xC0
	vF &= Climbing_TempY
	if vF != 0 then return

	# Check X limits
	vF := 96
	vF =- Climbing_TempX
	if vF != 0 then return
	vF := 16
	vF =- Climbing_TempX
	if vF != 0 then sprite Climbing_TempX Climbing_TempY Hold_Height
	;

## Index
# Climbing_TileX, Climbing_TileY
# Jumptable based on tile xy
: maptile_index

	;

## Tiles
# Tiles are 128x128
# Climbing_X, Climbing_Y are the offset into the map
#
:const Map_Width 4
:const Map_Height 4
:const Minimap_Address 0x3E00

:macro map_reset {
}

:macro map_begin x y {
	:calc minimap_addr { Minimap_Address + ( Map_Width * y ) + x }
	:calc map_x { 0 }
	:calc map_y { 0 }
}
:macro map_entry spr_id x y {
	:byte spr_id
	:calc x-delta { x - map_x }
	:byte x-delta
	:calc map_x { x }
	:calc y-delta { y - map_y }
	:byte y-delta
	:calc map_y { y }
}

map_reset
: maptile_0_0
	map_begin 0 0
	map_entry HOLD_3X3 10 12
	map_entry HOLD_3X5 30 30
	map_entry HOLD_END  0  0

: maptile_0_1
	map_begin 0 1
	map_entry HOLD_3X4 30 30
	map_entry HOLD_3X3 50 50
	map_entry HOLD_END  0  0

: maptile_0_2
	map_begin 0 2
	map_entry HOLD_END  0  0

: maptile_0_3
	map_begin 0 3
	map_entry HOLD_END  0  0

: maptile_1_0
	map_begin 1 0
	map_entry HOLD_END  0  0

: maptile_1_1
	map_begin 1 1
	map_entry HOLD_END  0  0

: maptile_1_2
	map_begin 1 2
	map_entry HOLD_END  0  0

: maptile_1_3
	map_begin 1 3
	map_entry HOLD_END  0  0

: maptile_2_0
	map_begin 2 0
	map_entry HOLD_END  0  0

: maptile_2_1
	map_begin 2 1
	map_entry HOLD_END  0  0

: maptile_2_2
	map_begin 2 2
	map_entry HOLD_END  0  0

: maptile_2_3
	map_begin 2 3
	map_entry HOLD_END  0  0

: maptile_3_0
	map_begin 3 0
	map_entry HOLD_END  0  0

: maptile_3_1
	map_begin 3 1
	map_entry HOLD_END  0  0

: maptile_3_2
	map_begin 3 2
	map_entry HOLD_END  0  0

: maptile_3_3
	map_begin 3 3
	map_entry HOLD_END  0  0


### Stuff that has to come after sprite declarations
: climbing_setup_drawlimb_lefthand
	Trampoline-Set-I-Const climbing_tramp_i:=handsprite spr_lefthand
	Trampoline-Set-jmp-Const climbing_tramp_jump_drawlimb_armleg climbing_drawlimb_arm
	i := climbing_data_lefthand
	;

: climbing_setup_drawlimb_righthand
	Trampoline-Set-I-Const climbing_tramp_i:=handsprite spr_righthand
	Trampoline-Set-jmp-Const climbing_tramp_jump_drawlimb_armleg climbing_drawlimb_arm
	i := climbing_data_righthand
	;

: climbing_setup_drawlimb_leftfoot
	Trampoline-Set-I-Const climbing_tramp_i:=handsprite spr_leftfoot
	Trampoline-Set-jmp-Const climbing_tramp_jump_drawlimb_armleg climbing_drawlimb_leg
	i := climbing_data_leftfoot
	;

: climbing_setup_drawlimb_rightfoot
	Trampoline-Set-I-Const climbing_tramp_i:=handsprite spr_rightfoot
	Trampoline-Set-jmp-Const climbing_tramp_jump_drawlimb_armleg climbing_drawlimb_leg
	i := climbing_data_rightfoot
	;
